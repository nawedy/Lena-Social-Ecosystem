<!-- CaptionEditor.svelte -->
<script lang="ts">
  import { createEventDispatcher } from 'svelte';
  import { fade } from 'svelte/transition';
  import type { Caption } from '$lib/types';
  import { formatTime } from '$lib/utils/video';

  const dispatch = createEventDispatcher();

  // Props
  export let captions: Caption[] = [];
  export let currentTime = 0;
  export let duration = 0;

  // State
  let selectedLanguage = 'en';
  let captionText = '';
  let startTime = currentTime;
  let endTime = currentTime + 5;
  let isUploading = false;
  let draggedCaptionId: string | null = null;

  const languages = [
    { code: 'en', name: 'English' },
    { code: 'es', name: 'Spanish' },
    { code: 'fr', name: 'French' },
    { code: 'de', name: 'German' },
    { code: 'it', name: 'Italian' },
    { code: 'pt', name: 'Portuguese' },
    { code: 'ru', name: 'Russian' },
    { code: 'ja', name: 'Japanese' },
    { code: 'ko', name: 'Korean' },
    { code: 'zh', name: 'Chinese' }
  ];

  $: sortedCaptions = [...captions]
    .filter(c => c.language === selectedLanguage)
    .sort((a, b) => a.startTime - b.startTime);

  $: currentCaption = sortedCaptions.find(caption => 
    currentTime >= caption.startTime && currentTime < caption.endTime
  );

  async function handleAddCaption() {
    if (!captionText.trim()) return;

    const caption: Caption = {
      id: crypto.randomUUID(),
      language: selectedLanguage,
      text: captionText.trim(),
      startTime,
      endTime,
      isAutoGenerated: false
    };

    dispatch('add', { caption });
    captionText = '';
    startTime = currentTime;
    endTime = Math.min(currentTime + 5, duration);
  }

  function handleDeleteCaption(captionId: string) {
    dispatch('delete', { captionId });
  }

  function handleCaptionClick(caption: Caption) {
    dispatch('seek', { time: caption.startTime });
  }

  function handleDragStart(event: DragEvent, caption: Caption) {
    draggedCaptionId = caption.id;
    event.dataTransfer?.setData('text/plain', caption.id);
  }

  function handleDragOver(event: DragEvent) {
    event.preventDefault();
    const target = event.target as HTMLElement;
    const captionItem = target.closest('.caption-item');
    if (captionItem) {
      captionItem.classList.add('drag-over');
    }
  }

  function handleDragLeave(event: Event) {
    const target = event.target as HTMLElement;
    const captionItem = target.closest('.caption-item');
    if (captionItem) {
      captionItem.classList.remove('drag-over');
    }
  }

  function handleDrop(event: DragEvent, targetCaption: Caption) {
    event.preventDefault();
    const target = event.target as HTMLElement;
    const captionItem = target.closest('.caption-item');
    if (captionItem) {
      captionItem.classList.remove('drag-over');
    }

    if (draggedCaptionId && draggedCaptionId !== targetCaption.id) {
      const draggedCaption = captions.find(c => c.id === draggedCaptionId);
      if (draggedCaption) {
        // Swap times between captions
        const tempStart = draggedCaption.startTime;
        const tempEnd = draggedCaption.endTime;
        
        draggedCaption.startTime = targetCaption.startTime;
        draggedCaption.endTime = targetCaption.endTime;
        
        targetCaption.startTime = tempStart;
        targetCaption.endTime = tempEnd;

        dispatch('update', { captions: [...captions] });
      }
    }
    draggedCaptionId = null;
  }

  async function handleFileUpload(event: Event) {
    const input = event.target as HTMLInputElement;
    const file = input.files?.[0];
    if (!file) return;

    isUploading = true;

    try {
      const text = await file.text();
      const parsedCaptions = parseSRT(text);
      
      for (const caption of parsedCaptions) {
        dispatch('add', {
          caption: {
            ...caption,
            id: crypto.randomUUID(),
            language: selectedLanguage,
            isAutoGenerated: false
          }
        });
      }
    } catch (error) {
      console.error('Failed to parse captions:', error);
      // TODO: Show error message to user
    } finally {
      isUploading = false;
      input.value = '';
    }
  }

  function parseSRT(srtContent: string) {
    const captions: Omit<Caption, 'id' | 'language' | 'isAutoGenerated'>[] = [];
    const blocks = srtContent.trim().split('\n\n');

    for (const block of blocks) {
      const lines = block.split('\n');
      if (lines.length < 3) continue;

      const times = lines[1].split(' --> ');
      if (times.length !== 2) continue;

      const startTime = timeToSeconds(times[0]);
      const endTime = timeToSeconds(times[1]);
      const text = lines.slice(2).join('\n');

      captions.push({ startTime, endTime, text });
    }

    return captions;
  }

  function timeToSeconds(timeStr: string): number {
    const [time, ms] = timeStr.split(',');
    const [hours, minutes, seconds] = time.split(':').map(Number);
    return hours * 3600 + minutes * 60 + seconds + Number(ms) / 1000;
  }
</script>

<div class="caption-editor">
  <div class="caption-controls">
    <select
      class="language-select"
      bind:value={selectedLanguage}
    >
      {#each languages as language}
        <option value={language.code}>{language.name}</option>
      {/each}
    </select>

    <label class="file-input">
      <input
        type="file"
        accept=".srt,.vtt"
        on:change={handleFileUpload}
        disabled={isUploading}
      />
      <span>
        {#if isUploading}
          Uploading...
        {:else}
          Import SRT/VTT
        {/if}
      </span>
    </label>
  </div>

  <div class="add-caption">
    <div class="time-controls">
      <div class="time-input">
        <label>Start</label>
        <input
          type="number"
          min="0"
          max={endTime}
          step="0.1"
          bind:value={startTime}
        />
      </div>
      <div class="time-input">
        <label>End</label>
        <input
          type="number"
          min={startTime}
          max={duration}
          step="0.1"
          bind:value={endTime}
        />
      </div>
    </div>

    <textarea
      class="caption-input"
      placeholder="Enter caption text"
      bind:value={captionText}
      rows="3"
    />

    <button
      class="add-button"
      disabled={!captionText.trim()}
      on:click={handleAddCaption}
    >
      Add Caption
    </button>
  </div>

  <div class="captions-list">
    {#if sortedCaptions.length === 0}
      <div class="empty-state" transition:fade>
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
          <path 
            stroke-linecap="round" 
            stroke-linejoin="round" 
            stroke-width="2"
            d="M7 8h10M7 12h4m1 4h5"
          />
          <rect x="3" y="4" width="18" height="16" rx="2" stroke-width="2" />
        </svg>
        <p>No captions added yet</p>
        <p class="hint">Add captions to make your video accessible to more viewers</p>
      </div>
    {:else}
      {#each sortedCaptions as caption}
        <div 
          class="caption-item"
          class:current={caption === currentCaption}
          draggable="true"
          on:click={() => handleCaptionClick(caption)}
          on:dragstart={(e) => handleDragStart(e, caption)}
          on:dragover={handleDragOver}
          on:dragleave={handleDragLeave}
          on:drop={(e) => handleDrop(e, caption)}
          transition:fade
        >
          <div class="caption-time">
            {formatTime(caption.startTime)} - {formatTime(caption.endTime)}
          </div>

          <div class="caption-text">
            {caption.text}
          </div>

          <button
            class="delete-button"
            on:click|stopPropagation={() => handleDeleteCaption(caption.id)}
            title="Delete caption"
          >
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
              <path 
                stroke-linecap="round" 
                stroke-linejoin="round" 
                stroke-width="2"
                d="M6 18L18 6M6 6l12 12"
              />
            </svg>
          </button>
        </div>
      {/each}
    {/if}
  </div>
</div>

<style lang="postcss">
  .caption-editor {
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  .caption-controls {
    display: flex;
    gap: 8px;
  }

  .language-select {
    flex: 1;
    padding: 8px 12px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 4px;
    color: white;
    font-size: 14px;
    cursor: pointer;

    &:focus {
      outline: none;
      border-color: var(--primary-color, #00a8ff);
    }
  }

  .file-input {
    position: relative;
    display: inline-block;

    input {
      position: absolute;
      width: 0;
      height: 0;
      opacity: 0;
    }

    span {
      display: inline-block;
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      color: white;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;

      &:hover {
        background: rgba(255, 255, 255, 0.2);
      }
    }
  }

  .add-caption {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .time-controls {
    display: flex;
    gap: 12px;
  }

  .time-input {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;

    label {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.7);
    }

    input {
      padding: 8px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      color: white;
      font-size: 14px;

      &:focus {
        outline: none;
        border-color: var(--primary-color, #00a8ff);
      }
    }
  }

  .caption-input {
    width: 100%;
    padding: 8px 12px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 4px;
    color: white;
    font-size: 14px;
    resize: vertical;

    &:focus {
      outline: none;
      border-color: var(--primary-color, #00a8ff);
    }

    &::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }
  }

  .add-button {
    align-self: flex-end;
    padding: 8px 16px;
    background: var(--primary-color, #00a8ff);
    border: none;
    border-radius: 4px;
    color: white;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;

    &:hover:not(:disabled) {
      filter: brightness(1.1);
    }

    &:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  }

  .captions-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
    max-height: 400px;
    overflow-y: auto;
    padding-right: 8px;
  }

  .empty-state {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    padding: 40px 20px;
    text-align: center;
    color: rgba(255, 255, 255, 0.5);

    svg {
      width: 48px;
      height: 48px;
      opacity: 0.5;
    }

    p {
      margin: 0;
      font-size: 14px;

      &.hint {
        font-size: 12px;
        opacity: 0.7;
      }
    }
  }

  .caption-item {
    position: relative;
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 12px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s;

    &:hover {
      background: rgba(255, 255, 255, 0.1);

      .delete-button {
        opacity: 1;
      }
    }

    &.current {
      border-left: 2px solid var(--primary-color, #00a8ff);
    }

    &.drag-over {
      border: 2px dashed var(--primary-color, #00a8ff);
    }
  }

  .caption-time {
    font-size: 12px;
    color: rgba(255, 255, 255, 0.7);
  }

  .caption-text {
    font-size: 14px;
    color: white;
    white-space: pre-wrap;
  }

  .delete-button {
    position: absolute;
    top: 8px;
    right: 8px;
    padding: 4px;
    background: transparent;
    border: none;
    color: rgba(255, 255, 255, 0.5);
    cursor: pointer;
    opacity: 0;
    transition: all 0.2s;

    &:hover {
      color: #ff4444;
    }

    svg {
      width: 16px;
      height: 16px;
    }
  }
</style> 